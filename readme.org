#+TITLE: Hecklist
#+PROPERTY: header-args :results output :exports both
#+OPTIONS: H:2 TOC:1 view:showall

A Haskell checklist for starting off projects, or starting over.

* Quick Start

Copy hecklist.hsfiles to wherever you start a new project and, if you have stack, type:

#+begin_src zsh
stack new foo hecklist
#+end_src

If you do not have stack, then first type:

#+begin_src zsh
ghcup install stack
#+end_src

If you do not have ghcup, then first type:

#+begin_src zsh
curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
#+end_src

The newly created project, ~foo~, should:

- Be fully conformant to both the stack and cabal ecosystems, and compile under either approach.
- Contain infrastructure for an executable, a library and testing.
- Correctly set up for haskell-language-server integration.
- Pass hlint and ormolu checks.
- Conform to become a GitHub repository, with a nicely badged readme and continuous integration support using GitHub actions.
- Pass CI tests across linux, osx and windows.

* Deeper dive

This project contains everything I need to bootstrap a new project, from setting up a Haskell environment, through creation of a new project, to creating a new GitHub repository with CI support.

These are salad days for the happy Haskell hacker. ~ghcup~ is the single-onboarding parent and insists that its charges play nicely with each other. ~haskell-language-server~ usage is locked in and leveraging lsp development. Checkers like hlint, ormolu, stan and cabal-docspecs can be mixed in and matched as needed. At least in terms of =How we start=, Haskell has found it's groove, balancing the efficiency of a centralised onboarding experience with an ability to adapt to and adopt new ways, means and technologies as they arise.

The template may not, however, contain what you need. For small changes, a direct edit of the hsfiles template with the [[http://mustache.github.io/mustache.5.html][mustache]] manual open is fairly easy. For deeper dives, or if you'd like to contribute bug fixes or develop your own checklist, then keep reading!

* Usage and Overview

This file, =readme.org=, is an org-mode file used to develop the template. It contains the template components but also the console commands used to bootstrap a new Haskell environment, and results of various steps towards getting together a working Haskell project.

Starting from scratch:

1. Set up a Haskell environment following the steps in [[#Haskell-and-Environs][Haskell and Environs]] This includes some notes on Doom emacs but any of the emacs preludes will also be fine.
2. modify the [[#Templates][Templates]] and run org-babel-tangle ~C-c C-v t~
3. Place hecklist.hsfiles where you want to create the new project and run ~stack new~ eg

  #+begin_src zsh
  stack new foo hecklist
  #+end_src

  Current defaults are ghc-8.10.4, lts-18.6 and Lib as the library name, but they are easily changed using stack, eg

  #+begin_src zsh
  stack new foo9 hecklist "ghc-version:9.0.1" -p "lib-name:Foo" -p "lib-name2:Bar" -p "resolver:nightly-2021-09-02"
  #+end_src

4. code, compile and test (see [[#Checklist][Checklist]] section).
5. Create a github repository and [[https://www.youtube.com/watch?v=vCadcBR95oU][push it]] (see [[#GitHub][GitHub]] section).

The repo should look something like [[https://github.com/tonyday567/foo][this]].

* Haskell and Environs
:PROPERTIES
:header-args :exports both
:END

Setup of Haskell is straight forward. [[https://www.haskell.org/ghcup/][ghcup]] takes care of ghc, cabal, stack, haskell-language-server and haddock executables, which are all placed in ~~​/.ghcup/bin~. ~cabal~ or ~stack~ can then be used to install the other tools, which are placed in ~~​/.cabal/bin~ or ~~​/.local/bin~.

** [[https://www.haskell.org/ghcup/][ghcup]]

#+begin_src zsh :results output
  curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
#+end_src

#+begin_src zsh :results output :exports both
which cabal
#+end_src

#+RESULTS:
: /Users/tonyday/.ghcup/bin/cabal

#+begin_src zsh :results output :exports both
cabal --version
#+end_src

#+RESULTS:
: cabal-install version 3.4.0.0
: compiled using version 3.4.0.0 of the Cabal library

#+begin_src zsh :results output
ghc --version
#+end_src

#+RESULTS:
: The Glorious Glasgow Haskell Compilation System, version 8.10.4

#+begin_src zsh :results output
stack --version
#+end_src

#+RESULTS:
: Version 2.7.3, Git revision 7927a3aec32e2b2e5e4fb5be76d0d50eddcc197f x86_64 hpack-0.34.4


~stack~ inspects the stack.yaml and selects the ghc that matches, so stack ghc and cabal ghc can be different.

#+begin_src zsh :rsults output
stack exec -- which ghc
#+end_src

#+RESULTS:
: /Users/tonyday/.ghcup/ghc/8.10.4/bin/ghc

#+begin_src zsh :rsults output
which ghc
#+end_src

#+RESULTS:
: /Users/tonyday/.ghcup/bin/ghc

#+begin_src zsh :results output
haddock --version
#+end_src

#+RESULTS:
: Haddock version 2.24.0, (c) Simon Marlow 2006
: Ported to use the GHC API by David Waern 2006-2008

#+begin_src zsh :results output
haskell-language-server --version
#+end_src

#+RESULTS:
: haskell-language-server version: 1.3.0.0 (GHC: 9.0.1) (PATH: /Users/tonyday/.ghcup/bin/haskell-language-server-9.0.1~1.3.0) (GIT hash: e7c5e90b6df5dff2760d76169eddaea3bdd6a831)

Note that haskell-langiuage-server versions matching older GHC versions are also installed, and selected automatically.

#+begin_src zsh :results output :text-properties t
ghcup list
#+end_src

#+RESULTS:
#+begin_example
   Tool  Version        Tags                      Notes
✗  ghc   7.10.3         base-4.8.2.0
✗  ghc   8.0.2          base-4.9.1.0
✗  ghc   8.2.2          base-4.10.1.0
✗  ghc   8.4.1          base-4.11.0.0
✗  ghc   8.4.2          base-4.11.1.0
✗  ghc   8.4.3          base-4.11.1.0
✗  ghc   8.4.4          base-4.11.1.0
✗  ghc   8.6.1          base-4.12.0.0
✗  ghc   8.6.2          base-4.12.0.0
✗  ghc   8.6.3          base-4.12.0.0
✗  ghc   8.6.4          base-4.12.0.0             hls-powered
✗  ghc   8.6.5          base-4.12.0.0             hls-powered
✗  ghc   8.8.1          base-4.13.0.0
✗  ghc   8.8.2          base-4.13.0.0
✗  ghc   8.8.3          base-4.13.0.0             hls-powered
✓  ghc   8.8.4          base-4.13.0.0             hls-powered
✗  ghc   8.10.1         base-4.14.0.0
✗  ghc   8.10.2         base-4.14.1.0             hls-powered
✗  ghc   8.10.3         base-4.14.1.0             hls-powered
✔✔ ghc   8.10.4         base-4.14.1.0             hls-powered
✗  ghc   8.10.5         base-4.14.2.0             hls-powered
✓  ghc   8.10.6         base-4.14.3.0
✗  ghc   8.10.7         recommended,base-4.14.3.0
✓  ghc   9.0.1          latest,base-4.15.0.0      hls-powered
✓  ghc   9.2.0.20210821 prerelease,base-4.16.0.0
✗  cabal 2.4.1.0
✗  cabal 3.0.0.0
✗  cabal 3.2.0.0
✔✔ cabal 3.4.0.0        latest,recommended
✓  hls   1.1.0
✓  hls   1.2.0
✔✔ hls   1.3.0          latest,recommended
✗  stack 2.5.1
✓  stack 2.7.1
✔✔ stack 2.7.3          latest,recommended
✔✔ ghcup 0.1.16.2       latest,recommended
#+end_example

** tools

- [[https://hackage.haskell.org/package/hlint][hlint]]
- [[https://hackage.haskell.org/package/ormolu][ormolu]]
- [[https://github.com/kowainik/stan#stan][stan]]
- [[https://hackage.haskell.org/package/haddock][haddock]]
- [[https://github.com/haskell-CI/haskell-ci][haskell-ci]]

#+begin_src zsh
cabal install ormolu hlint stan ghcid haskell-ci
#+end_src

~cabal~ stores executables in ~~​/.cabal/bin~, ~stack~ in ~~​/.local/bin~.

#+begin_src zsh :results output
which hlint
#+end_src

#+RESULTS:
: /Users/tonyday/.cabal/bin/hlint

** Haskell CI

GitHub actions is the current and common practice for continuous integration of projects. The [[https://github.com/haskell/actions/tree/main/setup#readme][haskell/action]] repo is the best place to find useful explanations.

Examples of non-trivial actions:
- [[https://github.com/haskell/haskell-language-server/tree/master/.github/workflows][haskell-language-server]]
- [[https://github.com/agda/agda/tree/master/.github/workflows][agda]]
- [[https://github.com/haskell/cabal/tree/master/.github/workflows][cabal]]

[[https://github.com/haskell-CI/haskell-ci][haskell-ci]] is a popular script generator for CI.

#+begin_example
haskell-ci dump-config > haskell-ci.config
{edit configuration}
haskell-ci github '--config=haskell-ci.config' 'cabal.project' --output .github/workflows/haskell-ci.yml
#+end_example

** cabal-docspec

[[https://github.com/phadej/cabal-extras/blob/master/cabal-docspec/MANUAL.md][cabal-docspec]] is a doctest runner that exists as a process outside the specification of a cabal project, in a similar manner to hlint, say.

#+begin_src zsh
git clone https://github.com/phadej/cabal-extras
cd cabal-extras/cabal-docspec
cabal install cabal-docspec:exe:cabal-docspec --allow-newer --overwrite-policy=always
#+end_src

** Doom emacs

Haskell setup for [[https://github.com/hlissner/doom-emacs#install][Doom]] emacs is straight-forward.

in ~.doom.d/init.el~, uncomment the haskell line and add lsp:

#+begin_src elisp
(haskell +lsp)      ; a language that's lazier than I am
#+end_src

in ~.ddom.d/config.el~, place any personal config preferences. Mine are:

#+begin_src elisp
;; haskell
;;
(after! haskell
  (setq
   haskell-font-lock-symbols t
   lsp-enable-folding nil
   lsp-response-timeout 120
   company-idle-delay nil
   lsp-ui-sideline-enable nil           ; not anymore useful than flycheck
   lsp-ui-doc-enable nil                ; slow and redundant with K
   lsp-enable-symbol-highlighting nil
   ;; If an LSP server isn't present when I start a prog-mode buffer, you
   ;; don't need to tell me. I know. On some systems I don't care to have a
   ;; whole development environment for some ecosystems.
   +lsp-prompt-to-install-server 'quiet
   )
 )
#+end_src

*** Literate Programming

An org file can also be used as a project readme. Sort of see [[https://github.com/novoid/github-orgmode-tests/blob/master/README.org]] for current state.

Haskell also works out of the box in org-mode these days and is worth playing around with for anyone interested in hacky literate programming.

[[https://necromuralist.github.io/posts/org-babel-cheat-sheet/][org babel cheat sheet]]

#+begin_src haskell :results value
x = 1
putStrLn $ show x
#+end_src

#+RESULTS:
: 1

* Templates
:PROPERTIES:
:header-args: :tangle hecklist.hsfiles
:END:

I use org-mode to stitch together a .hsfiles for use with the ~stack new~ templating system, which uses the [[http://mustache.github.io/mustache.5.html][Mustache]] specification under the hood. Values such as github-name tend to be picked up in the ~/.stack/config.yaml file.

** readme.md

Practice varies widely, from saying nothing to all documentation being in the readme. The readme.md template:

- adds some badges for Hackage, CI and dependencies.
- Includes a short description and basic Usage example, which I thing in many cases should be repeated exactly in the cabal file as synopsis and description stanzas.

#+begin_src org :tangle hecklist.hsfiles
{-# START_FILE readme.md #-}
{{name}}
===

[![Hackage](https://img.shields.io/hackage/v/{{name}}.svg)](https://hackage.haskell.org/package/{{name}})
[![Build Status](https://github.com/{{github-username}}/{{name}}/workflows/haskell-ci/badge.svg)](https://github.com/{{github-username}}/{{name}}/actions?query=workflow%3Ahaskell-ci) [![Hackage Deps](https://img.shields.io/hackage-deps/v/{{name}}.svg)](http://packdeps.haskellers.com/reverse/{{name}})

`{{name}}` is a new package.

Usage
==

``` haskell
import {{#lib-name}}{{lib-name}}{{#lib-name2}}.{{lib-name2}}{{/lib-name2}}{{/lib-name}}{{^lib-name}}Lib{{/lib-name}}
```
#+end_src

** [[https://www.haskell.org/cabal/][cabal]]

*** front matter

#+begin_src org
{-# START_FILE {{name}}.cabal #-}
cabal-version: 2.4
name:          {{name}}
version:       0.0.1
synopsis: See readme.md
description: See readme.md for description.
category: project
author: {{author-name}}{{^author-name}}Author name here{{/author-name}}
maintainer: {{author-email}}
copyright: {{copyright}}{{^copyright}}{{year}}{{^year}}2021{{/year}} {{authorName}}{{^authorName}}Author name here{{/authorName}}{{/copyright}}
license: BSD-3-Clause
homepage: https://github.com/{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}#readme
bug-reports: https://github.com/{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}/issues
build-type: Simple
tested-with: GHC == {{#ghc-version}}{{ghc-version}}{{/ghc-version}}{{^ghc-version}}8.10.4{{/ghc-version}}
source-repository head
  type: git
  location: https://github.com/{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}
#+end_src

*** common stanzas

https://vrom911.github.io/blog/common-stanzas

#+begin_src org :tangle hecklist.hsfiles
common common-options
  build-depends:
    base >=4.7 && <5
  default-language:
    Haskell2010

common ghc-options-stanza
  ghc-options:
    -Wall
    -Wcompat
    -Wincomplete-record-updates
    -Wincomplete-uni-patterns
    -Wredundant-constraints
    -fwrite-ide-info
    -hiedir=.hie
#+end_src

*** library stanza

#+begin_src org :tangle hecklist.hsfiles
library
  import: common-options
  import: ghc-options-stanza
  hs-source-dirs:
    src
  default-extensions:
  build-depends:
  exposed-modules:
    {{#lib-name}}{{lib-name}}{{#lib-name2}}.{{lib-name2}}{{/lib-name2}}{{/lib-name}}{{^lib-name}}Lib{{/lib-name}}
#+end_src

*** executable stanza

#+begin_src org :tangle hecklist.hsfiles
executable {{name}}
  import: common-options
  import: ghc-options-stanza
  main-is: app.hs
  hs-source-dirs: app
  build-depends:
    {{name}},
#+end_src

*** test stanza

I've left this test stanza in for completeness, but I'm tending to drop it altogether in preference to running cabal-docspec as a separate process to compilation.

#+begin_src org :tangle hecklist.hsfiles
test-suite test
  import: common-options
  import: ghc-options-stanza
  type: exitcode-stdio-1.0
  main-is: test.hs
  hs-source-dirs:
    test
  build-depends:
    doctest >= 0.15 && < 0.19,
    {{name}}
#+end_src

*** cabal.project

#+begin_src org :tangle hecklist.hsfiles
{-# START_FILE {{name}}.cabal #-}
packages: {{name}}.cabal

-- if doctests seem broken, uncomment:
-- See https://github.com/haskell/cabal/issues/6087
-- write-ghc-environment-files: always

allow-newer: true

-- Might be helpful when Hackage doesn't build properly...
-- keep-going: True
#+end_src

** library

#+begin_src org :tangle hecklist.hsfiles
{-# START_FILE src/{{#lib-name}}{{lib-name}}{{#lib-name2}}/{{lib-name2}}{{/lib-name2}}{{/lib-name}}{{^lib-name}}Lib{{/lib-name}}.hs #-}
{-# OPTIONS_GHC -Wall #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}

module {{#lib-name}}{{lib-name}}{{#lib-name2}}.{{lib-name2}}{{/lib-name2}}{{/lib-name}}{{^lib-name}}Lib{{/lib-name}}
  (
  )
where

import Prelude
#+end_src

** app

#+begin_src org :tangle hecklist.hsfiles
{-# START_FILE app/app.hs #-}
{-# OPTIONS_GHC -Wall #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}

import {{#lib-name}}{{lib-name}}{{#lib-name2}}.{{lib-name2}}{{/lib-name2}}{{/lib-name}}{{^lib-name}}Lib{{/lib-name}}
import Prelude

-- $setup
-- >>> import Prelude

-- | doctest
-- >>> putStrLn "doctest ok"
-- doctest ok
main :: IO ()
main = pure ()
#+end_src

Calling the file {{name}}.hs doesn't seem to work well, here, with the Name becoming capitalised somewhere.

** test

#+begin_src org :tangle hecklist.hsfiles
{-# START_FILE test/test.hs #-}
{-# OPTIONS_GHC -Wall #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}

module Main where

import Test.DocTest
import Prelude

main :: IO ()
main =
  doctest
    [ "src/{{#lib-name}}{{lib-name}}{{#lib-name2}}/{{lib-name2}}{{/lib-name2}}{{/lib-name}}{{^lib-name}}Lib{{/lib-name}}.hs",
      "app/app.hs"
    ]
#+end_src

** stack

#+begin_src org :tangle hecklist.hsfiles
{-# START_FILE stack.yaml #-}
resolver: {{#resolver}}{{resolver}}{{/resolver}}{{^resolver}}lts-18.6{{/resolver}}

packages:
  - .
#+end_src

** git

The .gitignore reflects the slow expansion of cruft as tools accumulate. .stack-work is stack's working directory. cabal's working directory, dist-newstyle, seems less well-named, since it keeps everything about a build and the old style has been lost to time.

stack.yaml.lock seems to be like cabal.freeze, in that it is never needed until it is, when you can never find it. cabal fusses a lot over cabal.project.local and accumulates as many backups as you have compilation loops, just in case you forget that you didn't want to ignore the project ever.

Everyone uses .hie these days which are some form of cache for ghc, used especially by hls.

.gitattributes can help if your project is mis-labelled in github due to excessive html or whatnot being included in the project.

#+begin_src org :tangle hecklist.hsfiles
{-# START_FILE .gitignore #-}
/.stack-work/
/dist-newstyle/
stack.yaml.lock
**/.DS_Store
cabal.project.local*
/.hie/
#+end_src

#+begin_src org :tangle hecklist.hsfiles
{-# START_FILE .gitattributes #-}
other/* linguist-documentation
#+end_src

** hls

In emacs, haskell-language-server uses projectile to discover the project root directory, which is indicated by an empty ~.projectile~ file.

#+begin_src org :tangle hecklist.hsfiles
{-# START_FILE .projectile #-}
#+end_src

~hls~ uses the presence of a ~stack.yaml~ file as an indication that stack should be used, and the creation of this file hard-codes cabal as the preferred compilation tool.

#+begin_src org :tangle hecklist.hsfiles
{-# START_FILE hie.yaml #-}
cradle:
  cabal:
    - path: "./app/{{name}}.hs"
      component: "{{name}}:exe:{{name}}"
    - path: "./src"
      component: "{{name}}:lib"
    - path: "./test/{{name}}.hs"
      component: "{{name}}:test:{{name}}"
#+end_src

** licence

Hard-coded BSD3.

#+begin_src org :tangle hecklist.hsfiles
{-# START_FILE LICENSE #-}
Copyright {{author-name}}{{^author-name}}Author name here{{/author-name}} (c) {{year}}{{^year}}2021{{/year}}

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of {{author-name}}{{^author-name}}Author name here{{/author-name}} nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#+end_src

** action

#+begin_src org :tangle hecklist.hsfiles
{-# START_FILE .github/workflows/Haskell-CI.yml #-}
{{=>> <<=}}
on: [push]
name: haskell-ci
jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        ghc: ['>>#ghc-version<<>>ghc-version<<>>/ghc-version<<>>^ghc-version<<8.10.4>>/ghc-version<<']
        os: [ubuntu-latest, macOS-latest, windows-latest]
        stack: [true, false]
    name: ghc ${{ matrix.ghc }} ${{ matrix.os }}
    steps:
      - name: clone project
        uses: actions/checkout@v2
      - name: setup stanza
        uses: haskell/actions/setup@v1
        with:
          ghc-version: ${{ matrix.ghc }}
          cabal-version: 3.4
          enable-stack: true
          stack-version: 'latest'
      - name: stack cache
        if: matrix.stack == 'true'
        uses: actions/cache@v1
        with:
          path: ~/.stack
          key: ${{ runner.os }}-${{ hashFiles('stack.yaml') }}
          restore-keys: ${{ runner.os }}-
      - name: cabal cache
        if: matrix.stack == 'false'
        uses: actions/cache@v2
        with:
          key: ${{ runner.os }}-${{ matrix.ghc }}-${{ github.sha }}
          path: ~/.cabal/store
          restore-keys: ${{ runner.os }}-${{ matrix.ghc }}-
      - name: cabal build
        if: matrix.stack == 'false'
        run: |
          cabal update
          cabal configure --enable-tests
          cabal build
          cabal test
      - name: stack build
        if: matrix.stack == 'true'
        run: |
          stack update
          stack build --test --no-install-ghc --system-ghc
    >>={{ }}=<<
    #+end_src

If you would like to go full-steam, such as include hlint and cabal-docspecs, haskell-ci is a very good tool, though it doesn't (yet) support stack or windows CI.

* Checklist
:PROPERTIES:
:header-args: :tangle hecklist.hsfiles :dir ./foo :language zsh
:END:

I use this section to record results of compilation steps, and the process of polishing projects.

** Front matter

Edit properties in [[#Checklist][Checklist]] to point to the right directory.

#+begin_src zsh
ls -la
#+end_src

#+RESULTS:
| total      | 72 |         |       |      |   |     |       |                     |
| drwxr-xr-x | 20 | tonyday | staff |  640 | 3 | Sep | 09:01 | .                   |
| drwxr-xr-x |  8 | tonyday | staff |  256 | 3 | Sep | 08:08 | ..                  |
| drwxr-xr-x | 12 | tonyday | staff |  384 | 2 | Sep | 21:29 | .git                |
| -rw------- |  1 | tonyday | staff |   31 | 2 | Sep | 10:40 | .gitattributes      |
| drwxr-xr-x |  3 | tonyday | staff |   96 | 2 | Sep | 10:40 | .github             |
| -rw------- |  1 | tonyday | staff |   87 | 2 | Sep | 10:40 | .gitignore          |
| drwxr-xr-x |  4 | tonyday | staff |  128 | 2 | Sep | 10:40 | .hie                |
| -rw------- |  1 | tonyday | staff |    0 | 2 | Sep | 10:40 | .projectile         |
| drwxr-xr-x |  5 | tonyday | staff |  160 | 2 | Sep | 17:16 | .stack-work         |
| -rw------- |  1 | tonyday | staff | 1513 | 2 | Sep | 10:40 | LICENSE             |
| drwxr-xr-x |  3 | tonyday | staff |   96 | 2 | Sep | 10:40 | app                 |
| -rw-r--r-- |  1 | tonyday | staff |   34 | 3 | Sep | 09:01 | cabal.project.local |
| drwxr-xr-x |  6 | tonyday | staff |  192 | 3 | Sep | 09:01 | dist-newstyle       |
| -rw------- |  1 | tonyday | staff | 1318 | 2 | Sep | 10:40 | foo.cabal           |
| -rw------- |  1 | tonyday | staff |  182 | 2 | Sep | 10:40 | hie.yaml            |
| -rw------- |  1 | tonyday | staff |  432 | 2 | Sep | 10:40 | readme.md           |
| drwxr-xr-x |  3 | tonyday | staff |   96 | 2 | Sep | 17:16 | src                 |
| -rw------- |  1 | tonyday | staff |   36 | 2 | Sep | 10:40 | stack.yaml          |
| -rw------- |  1 | tonyday | staff |  447 | 2 | Sep | 17:16 | stack.yaml.lock     |
| drwxr-xr-x |  3 | tonyday | staff |   96 | 2 | Sep | 10:40 | test                |

Check/set the ghc version

#+begin_src zsh
ghcup set ghc 8.10.4
#+end_src

#+RESULTS:

** Compiling

- [[https://www.haskell.org/cabal/][cabal]]

  #+begin_src zsh
  cabal clean
  #+end_src

  #+RESULTS:

  It's so very useful to check the build plan before actiually building, as ~cabal configure~ does.

  #+begin_src zsh :results output
  cabal configure --enable-tests
  #+end_src

  #+RESULTS:
  : 'cabal.project.local' already exists, backing it up to
  : 'cabal.project.local~5'.
  : Resolving dependencies...
  : Build profile: -w ghc-8.10.4 -O1
  : In order, the following would be built (use -v for more details):
  :  - doctest-0.18.1 (exe:doctest) (requires build)
  :  - foo-0.0.1 (lib) (first run)
  :  - foo-0.0.1 (test:test) (first run)
  :  - foo-0.0.1 (exe:foo) (first run)


  #+begin_src zsh :results output
  cabal build
  #+end_src

  #+RESULTS:
  #+begin_example
  Build profile: -w ghc-8.10.4 -O1
  In order, the following will be built (use -v for more details):
   - foo-0.0.1 (lib) (first run)
   - foo-0.0.1 (test:test) (first run)
   - foo-0.0.1 (exe:foo) (first run)
  Configuring library for foo-0.0.1..
  Preprocessing library for foo-0.0.1..
  Building library for foo-0.0.1..
  [1 of 1] Compiling Lib              ( src/Lib.hs, /Users/tonyday/haskell/hecklist/foo/dist-newstyle/build/x86_64-osx/ghc-8.10.4/foo-0.0.1/build/Lib.o, /Users/tonyday/haskell/hecklist/foo/dist-newstyle/build/x86_64-osx/ghc-8.10.4/foo-0.0.1/build/Lib.dyn_o )
  Configuring test suite 'test' for foo-0.0.1..
  Configuring executable 'foo' for foo-0.0.1..
  Preprocessing executable 'foo' for foo-0.0.1..
  Building executable 'foo' for foo-0.0.1..
  Preprocessing test suite 'test' for foo-0.0.1..
  Building test suite 'test' for foo-0.0.1..
  [1 of 1] Compiling Main             ( app/app.hs, /Users/tonyday/haskell/hecklist/foo/dist-newstyle/build/x86_64-osx/ghc-8.10.4/foo-0.0.1/x/foo/build/foo/foo-tmp/Main.o )
  [1 of 1] Compiling Main             ( test/test.hs, /Users/tonyday/haskell/hecklist/foo/dist-newstyle/build/x86_64-osx/ghc-8.10.4/foo-0.0.1/t/test/build/test/test-tmp/Main.o )
  Linking /Users/tonyday/haskell/hecklist/foo/dist-newstyle/build/x86_64-osx/ghc-8.10.4/foo-0.0.1/x/foo/build/foo/foo ...
  Linking /Users/tonyday/haskell/hecklist/foo/dist-newstyle/build/x86_64-osx/ghc-8.10.4/foo-0.0.1/t/test/build/test/test ...
  #+end_example

  #+begin_src zsh :results output
  cabal test
  #+end_src

  #+RESULTS:
  #+begin_example
  Build profile: -w ghc-8.10.4 -O1
  In order, the following will be built (use -v for more details):
   - foo-0.0.1 (test:test) (ephemeral targets)
  Preprocessing test suite 'test' for foo-0.0.1..
  Building test suite 'test' for foo-0.0.1..
  Running 1 test suites...
  Test suite test: RUNNING...
  Test suite test: PASS
  Test suite logged to:
  /Users/tonyday/haskell/hecklist/foo/dist-newstyle/build/x86_64-osx/ghc-8.10.4/foo-0.0.1/t/test/test/foo-0.0.1-test.log
  1 of 1 test suites (1 of 1 test cases) passed.
  #+end_example

- [[https://docs.haskellstack.org/en/stable/README/][stack]]

  #+begin_src zsh :results raw
    stack build --test
  #+end_src

  #+RESULTS:

- full compile with -Werror

    #+begin_src zsh :results output
    stack build --test --haddock --no-haddock-deps --ghc-options -Werror --ghc-options -Wcompat --ghc-options -Wincomplete-record-updates --ghc-options -Wincomplete-uni-patterns --ghc-options -Wredundant-constraints
    #+end_src

- development loops

  =haskell-language-server= works well for code that has recently compiled, but tends to suffer when fed projects that are less than pristine already. To bootstrap from a mess of garbage like I usually do, use =ghcid= and, when this falls over, revert to =stack build --test --file-watch= which will never fail.

** Linting

- [[https://hackage.haskell.org/package/hlint][hlint]]
  #+begin_src zsh :results output
  hlint .
  #+end_src

  #+RESULTS:
  : No hints

- [[https://hackage.haskell.org/package/ormolu][ormolu]]

  (~--mode inplace~ to actually change haskell files)

  #+begin_src zsh :results output
  ormolu --mode check $(git ls-files '*.hs')
  #+end_src

  #+begin_src zsh :results output
  ormolu --mode check */*.hs
  #+end_src

  #+RESULTS:

** Analysis

- [[https://github.com/kowainik/stan#stan][stan]]
  #+begin_src zsh :results output
  stan
  #+end_src

  #+RESULTS:
  #+begin_example
    ⓘ Checking environment variables and CLI arguments for default configurations file usage...
      Fiasco:
        * [Error  ] No STAN_USE_DEFAULT_CONFIG Env Variable is set
        ,* [Error  ] No CLI option specified for no-default

    ⓘ The following Configurations are used:

      Result:

      With the following warnings:
        * [Warning] TOML Configurations file doesn't exist: /Users/tonyday/haskell/hecklist/foo/.stan.toml
        ,* [Warning] TOML Configurations file doesn't exist: /Users/tonyday/.stan.toml
        ,* [Warning] No CLI option specified for: checks
        ,* [Warning] configChecks is set through the source: Default
        ,* [Warning] TOML Configurations file doesn't exist: /Users/tonyday/haskell/hecklist/foo/.stan.toml
        ,* [Warning] TOML Configurations file doesn't exist: /Users/tonyday/.stan.toml
        ,* [Warning] No CLI option specified for: remove
        ,* [Warning] configRemoved is set through the source: Default
        ,* [Warning] TOML Configurations file doesn't exist: /Users/tonyday/haskell/hecklist/foo/.stan.toml
        ,* [Warning] TOML Configurations file doesn't exist: /Users/tonyday/.stan.toml
        ,* [Warning] No CLI option specified for: ignore
        ,* [Warning] configIgnored is set through the source: Default

    ⓘ Using the following .cabal file: /Users/tonyday/haskell/hecklist/foo/foo.cabal

    ✔ All clean! Stan did not find any observations at the moment.

             Stan's Summary:
  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━┓
  ┃ Analysed modules             ┃ 2      ┃
  ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━┫
  ┃ Analysed Lines of Code       ┃ 23     ┃
  ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━┫
  ┃ Total Haskell2010 extensions ┃ 0      ┃
  ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━┫
  ┃ Total SafeHaskell extensions ┃ 0      ┃
  ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━┫
  ┃ Total checked inspections    ┃ 44     ┃
  ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━┫
  ┃ Total found observations     ┃ 0      ┃
  ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━┫
  ┃ Total ignored observations   ┃ 0      ┃
  ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╋━━━━━━━━┫
  ┃ Project health               ┃ 100%   ┃
  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┻━━━━━━━━┛

  #+end_example

- [[https://hackage.haskell.org/package/haddock][haddock]]
  #+begin_src zsh :results output
  cabal haddock
  #+end_src

  #+RESULTS:
  #+begin_example
  Build profile: -w ghc-8.10.4 -O1
  In order, the following will be built (use -v for more details):
   - foo-0.0.1 (lib) (ephemeral targets)
  Preprocessing library for foo-0.0.1..
  Running Haddock on library for foo-0.0.1..
  Haddock coverage:
     0% (  0 /  1) in 'Lib'
    Missing documentation for:
      Module header
  Documentation created:
  /Users/tonyday/haskell/hecklist/foo/dist-newstyle/build/x86_64-osx/ghc-8.10.4/foo-0.0.1/doc/html/foo/index.html
  #+end_example

- [[https://hackage.haskell.org][Hackage]]

  Sometimes haddocks don't build on Hackage. Here's a recipe for uploading your own docs.

  #+begin_src zsh
  cabal haddock --builddir=docs --haddock-for-hackage --enable-doc
  cabal upload -d --publish docs/*-docs.tar.gz
  #+end_src

* GitHub

#+begin_src zsh results: output
cd foo
git init
git add .gitignore
git add **
git add .**
git commit -m "new project - forced automated commit"
git remote add origin https://github.com/tonyday567/foo.git
git push origin main --force
#+end_src

#+RESULTS:
: Reinitialized existing Git repository in /Users/tonyday/haskell/hecklist/foo/.git/
: On branch main
: nothing to commit, working tree clean
